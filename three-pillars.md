## Thesis: Why Retro Matters in HCI

Retro matters because it helps us ask an important question in Human–Computer Interaction:

> *What kinds of software appear when we assume different ways of using our hands, eyes, and attention, different rhythms, and different limits?*

This idea rests on three simple pillars: people, media, and things.

First, software is built around assumptions about people. Input devices, screens, speed, and feedback all shape what actions feel easy or hard. When these assumptions change, how people use software changes too. Software does not just respond to the body—it trains the body.

Second, media shape how we see and pay attention. Screen size and shape matter. A 4:3 screen keeps most information close to the center, which encourages focused looking rather than wide scanning. This affects how interfaces are laid out and how users think while using them. Screens do not just show information; they guide attention.

Third, skill comes from working with things, not from people alone. Tools take part in action. A mechanical ball mouse had weight and friction, so users learned to spin it, stop it, and lift it in specific ways. Over time, people built muscle memory around these movements, and software was designed to allow rough but intentional control instead of perfect precision.

Together, these points show that interfaces are physical habits shaped by bodies, timing, and limits. Older systems explored different ways of working because their limits were different, not because designers were worse. These systems are useful evidence, not just old memories.

By studying retro systems, we can see which interaction styles still work when input is imprecise, slow, or limited. We can see which designs support intention instead of constant correction, and which ideas break down when attention or accuracy drops.

Limits return in new forms: wearables, augmented reality, AI-driven tools, accessibility needs, and low-power devices all reduce speed, precision, or attention. Because of this, lessons from past systems help us predict what kinds of interfaces will work in the future.

Retro systems matter in HCI because they reveal how different bodily limits, media conditions, and material tools produce stable interaction styles—and those conditions are returning in new forms.

Without retro perspectives, today’s design habits can feel universal even when they are fragile. Retro keeps many ways of interacting alive, helping us design software that is more flexible, humane, and ready for what comes next.

---

## Introducing the Structure: Three Pillars to a Reconstruction Method

Many older games and applications can still be run today, but they often do not *feel* right. Controls may feel too fast or too loose, movement can look strange, timing can feel off, and difficulty can subtly change. Even when graphics and sound appear correct, something about the experience is different.

This happens because software is designed around assumptions about how people move, see, and react. Those assumptions are closely tied to the hardware, software layers, and media conditions of a specific time. When those conditions change, the interaction changes as well.

To make sense of this, the thesis uses three connected lenses. These are not abstract theories, but practical ways of looking at how software worked in the real world.

First, there is **human interaction**. Software assumes certain ways of using hands, eyes, and attention. A game may expect quick flicks rather than careful adjustment, or focused attention rather than wide scanning. These expectations shape which input devices and screen types feel natural and which feel wrong.

Second, there is **the medium itself**. Screen shape affects where people look. Display technology affects motion and contrast. Audio systems affect timing and spatial sense. Even when content is unchanged, differences in the medium can quietly alter how an experience feels.

Third, there is **the real system as it existed in the world**. Not every combination of hardware and software was ever practical, stable, or widely used. Systems that existed only briefly or were hard to maintain did not have time to train users or settle into reliable use. Systems that lasted for years matter more than ones that only existed in theory.

Taken together, these three concerns lead naturally to a reconstruction structure. The process begins with the software itself, then works outward:

1. What kind of interaction does this software expect from the user?
2. What input devices and screen types support that interaction?
3. What graphics and audio APIs shape timing, precision, and feedback?
4. Where do modern substitutions introduce hidden changes or anachronisms?
5. Did a real machine with these characteristics exist at the time?
6. Did this type of system remain usable and maintained long enough to matter?

This structure is not meant to chase perfect accuracy or nostalgia. Its purpose is to rebuild software around the human skills and media conditions it expected, and to use past systems as evidence for how different interaction styles emerge, stabilize, and fade over time.
